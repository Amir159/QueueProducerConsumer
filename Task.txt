Поскольку некоторые из вас уже справились с первым заданием, вот вам второе задание.
 
Нужно реализовать паттерн Producer/Consumer. Суть паттерна заключается в том, что первый куда-то пишет, а второй откуда-то читает, то есть в некоторую очередь. При этом интерес для нас он представляет тогда, когда мы эту очередь ограничиваем. Сделаем это так:


	
Producer и Consumer - это два потока (единственные два потока, которые запускаются в вашем приложении, кроме main)
	
Очередь - это Queue<Integer> queue = new LinkedList<>();
	
Есть максимальный размер очереди MAX_QUEUE_LENGTH = 10
	
Producer будет делать queue.add, если очередь не превышает MAX_QUEUE_LENGTH
	
Consumer будет делать queue.poll, если очередь не пуста
	
Каждый из них работает в бесконечном цикле
	
В конце каждого витка цикла выводите количество элементов в очереди на экран
	
Если кто-то из них не может выполнить очередную операцию, то  выводите на экран "can't poll" или "can't add"

Надо написать 2 реализации:


	
Если кто-то из них не может выполнить очередную операцию, то просто пропускаете виток цикла. Вы увидите, что эти сообщения будут встречаться гораздо чаще, чем сообщения о том, сколько сейчас элементов в очереди.
	
(Со звездочкой) Улучшаете первую реализацию, заменив пропуск витка цикла на wait-nofity. Задача нетривиальная, так как я не дала вам теорию по wait-notify.

 
 
План такой:


	
Первая реализация очевидная, поэтому её я в любом случае жду в понедельник.
	
Вторая вызовет затруднения, поэтому её я не жду в понедельник. Здесь предлагаю поступить так. В понедельник в конце лекции по SQL я могу дать теорию по wait-nofity и/или ответить на ваши накопившиеся по этому поводу вопросы.